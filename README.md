# Mediasoft, тестовое задание по Python (hard)

**Автор** - Арутюнян Дмитрий Аркадьевич, УлГТУ, ПИбд-42.

**Ссылка на задание** - https://drive.google.com/file/d/1wYOReeTobVEcUBJiqEgj9S0YcdPQzAAh/view?usp=sharing


# Описание проекта
## Содержание

* [Введение](#Введение)
* [Как запустить](#Как-запустить)
* [Описание API](#Описание-API)
  * [Блог](#Блог)  
  * [Пост](#Пост)  
  * [Комментарий](#Комментарий)  
  * [Пользователь](#Пользователь)  
  * [Пагинация](#Пагинация)
  * [Сортировка, Поиск, Фильтры](#Сортировка-Поиск-Фильтры)
* [Описание моделей](#Описание-моделей)
  * [Модель блога](#Модель-блога)  
  * [Модель поста](#Модель-поста)  
  * [Модель комментария](#Модель-комментария)  
  * [Модель отметки "нравится"](#Модель-отметки-нравится)
  * [Модель подписки](#Модель-подписки)
* [Тестирование](#Тестирование)
* [Стек технологий](#Стек-технологий)
* [Используемые источники](#Используемые-источники)


## Введение

Приложение Social Net - REST-реализация сервиса социальной сети, включающая в себя 
систему хостинга блогов и постов, возможности теггирования, комментирования и 
администрирования.


## Как запустить

Шаг 1. Убедитесь, что у вас установлен `Docker` и `Docker Compose`.

Шаг 2. Клонируйте репозиторий:

  ```bash
  git clone https://github.com/Arutunyan-Dmitry/mediasoft-practice.git
  cd mediasoft-practice
  ```

Шаг 3. Создайте файл `.env` в корневой папке проекта и добавьте необходимые переменные окружения:

  ```yaml
  POSTGRES_HOST=your_postgres_host
  POSTGRES_PORT=your_postgres_port
  POSTGRES_USER=your_postgres_user
  POSTGRES_PASSWORD=postgres_user_password
  POSTGRES_DB=social_your_postgres_db_name
  ```

Шаг 4. Запустите контейнеры с помощью `docker-compose`:

  ```bash
  docker-compose up --build
  ```

Шаг 5. После успешного запуска контейнеров, API приложения Social Net будет доступен по 
адресу http://localhost:8000/api/v1/.

Шаг 6. Для остановки контейнеров выполните:

  ```bash
  docker-compose down
  ```

> [!TIP]
> Поскольку образ приложения также находится в `DockerHub` репозитории, есть возможность 
> запустить приложение без клонирования репозитория целиком. Для этого сохраните только  
> файл `docker-compose.yaml` и замените в нём строки:
>  ```yaml
>  build:
>        context: ./socialnet
>        dockerfile: ./Dockerfile
>   ```
> на строку 
> ```yaml 
> image: arutunyandmitry/social-net:latest
> ```

> Ссылка на `DockerHub` репозиторий [тут](https://hub.docker.com/repository/docker/arutunyandmitry/social-net/general)


## Описание API
## Блог

| Конечная точка                                       | Доступные методы                             | Краткое описание                                           |
|------------------------------------------------------|----------------------------------------------|------------------------------------------------------------|
| [`/blog/`](#Чтение-списка-блогов-создание-блога)     | * GET,<br/>* POST                            | Чтение списка блогов, создание блога                       |
| [`/blog/subscribes/`](#Мои-подписки)                 | * GET                                        | Чтение списка блогов, находящихся в подписках пользователя |
| [`/blog/<slug>/`](#Чтение-обновление-удаление-блога) | * GET,<br/>* PUT,<br/>* PATCH,<br/> * DELETE | Чтение блога, обновление блога, удаление блога             |
| [`/blog/<slug>/author/`](#Авторы-блога)              | * POST,<br/> * DELETE                        | Добавление авторов в блог, удаление авторов из блога       |
| [`/blog/<slug>/subscribe/`](#Оформление-подписки)    | * POST,<br/> * DELETE                        | Подписка на блог, отписка от блога                         |
| [`/blog/<slug>/posts/`](#Посты-блога)                | * GET                                        | Чтение списка постов блога                                 |


### Чтение списка блогов, создание блога
***

По данной конечной точке приложение отправляет список всех блогов в порядке их новизны (начиная с 
блога, в котором публикация последнего поста была недавно). Для списка сущностей блогов реализованы 
[пагинация](#Пагинация), [сортировки](#Сортировка-поиск-фильтры-блогов), 
[поиск](#Сортировка-поиск-фильтры-блогов) и [фильтры](#Сортировка-поиск-фильтры-блогов). 
Данные, полученные с этой конечной точки могут использоваться на странице `Список блогов`.

Также данная конечная точка используется для создания нового блога.

> **Представления**: `BlogViewSet`
> 
> **Сериализаторы**: `SlugSerializer`, `BlogSerializer`, `CreateOrUpdateBlogSerializer`

> **Права доступа** 
> 
> *Чтение* - доступно всем пользователям
> 
> *Запись* - доступно авторизованным пользователям

> [!NOTE]
> При создании блога, его слаг генерируется автоматически как: "имя автора"-"заголовок блога".
> Такой подход генерации слага делает запись блога уникальной в контексте одного пользователя и
> запрещает создавать одному автору несколько блогов с одинаковым названием в целях экономии памяти.

| Метод |         Запрос         | Ответ                                                         |
|-------|:----------------------:|---------------------------------------------------------------|
| GET   |           -            | HTTP_200_OK <br/> `{ count, previous, next, {{ Blog }, ... }` |
| POST  | `{title, description}` | * HTTP_201_CREATED<br/>* HTTP_400_BAD_REQUEST                 |


### "Мои подписки"
***

По данной конечной точке приложение отправляет список блогов, на которые подписан пользователь, 
в порядке их новизны (начиная с блога, в котором публикация последнего поста была недавно). 
Для списка сущностей блогов реализованы [пагинация](#Пагинация), [сортировки](#Сортировка-поиск-фильтры-блогов), 
[поиск](#Сортировка-поиск-фильтры-блогов) и [фильтры](#Сортировка-поиск-фильтры-блогов).

> **Представления**: `SubscribesListView`
> 
> **Сериализаторы**: `BlogSerializer`

> **Права доступа** - доступно авторизованным пользователям

| Метод | Запрос | Ответ                                                         |
|-------|:------:|---------------------------------------------------------------|
| GET   |   -    | HTTP_200_OK <br/> `{ count, previous, next, {{ Blog }, ... }` |


### Чтение, обновление, удаление блога
***

По данной конечной точке пользователь может извлечь определённую сущность блога, обновить 
или удалить её.

> **Представления**: `BlogViewSet`
> 
> **Сериализаторы**: `SlugSerializer`, `BlogSerializer`, `CreateOrUpdateBlogSerializer`

> **Права доступа** 
> 
> *Чтение* - доступно авторизованным пользователям
> 
> *Обновление, удаление* - доступно только создателю блога или администратору

> [!WARNING]
> При удалении сущности блога, все его посты также удаляются.

| Метод  |               Запрос               | Ответ                                |
|--------|:----------------------------------:|--------------------------------------|
| GET    |                 -                  | HTTP_200_OK <br/> `{{ Blog }}`       |
| PUT    |       `{title, description}`       | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| PATCH  | `{{title}}`<br/> `{{description}}` | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| DELETE |                 -                  | HTTP_204_NO_CONTENT                  |


### Авторы блога
***

По данной конечной точке владелец блога может добавлять и удалять авторов, которым 
предоставляются права создания и публикации постов в блог.

> **Представления**: `BlogViewSet`
> 
> **Сериализаторы**: `AuthorSerializer`

> **Права доступа** - доступно только создателю блога или администратору

> [!NOTE]
> Владелец блога является его автором по умолчанию.

| Метод  |           Запрос           | Ответ                                        |
|--------|:--------------------------:|----------------------------------------------|
| POST   | `{{authors: [User, ...]}}` | HTTP_204_NO_CONTENT<br/>HTTP_400_BAD_REQUEST |
| DELETE | `{{authors: [User, ...]}}` | HTTP_204_NO_CONTENT<br/>HTTP_400_BAD_REQUEST |


### Оформление подписки
***

По данной конечной точке пользователь может подписаться на любой блог и отписаться 
от него.

> **Представления**: `BlogViewSet`
> 
> **Сериализаторы**: `SubscribeSerializer`

> **Права доступа** - доступно авторизованным пользователям

| Метод  | Запрос | Ответ               |
|--------|:------:|---------------------|
| POST   |   -    | HTTP_204_NO_CONTENT |
| DELETE |   -    | HTTP_204_NO_CONTENT |


### "Посты блога"
***

По данной конечной точке приложение отправляет список постов, находящихся 
в определённом блоге. Для списка сущностей постов реализованы [пагинация](#Пагинация), 
[сортировки](#Сортировка-поиск-фильтры-постов), [поиск](#Сортировка-поиск-фильтры-постов) 
и [фильтры](#Сортировка-поиск-фильтры-постов).

> **Представления**: `BlogPostsListView`
> 
> **Сериализаторы**: `PostSerializer`

> **Права доступа** - доступно всем пользователям

> [!NOTE]
> По умолчанию список строится только из опубликованных постов, но для администратора и 
> владельца блога он пополняется неопубликованными постами.

| Метод | Запрос | Ответ                                                         |
|-------|:------:|---------------------------------------------------------------|
| GET   |   -    | HTTP_200_OK <br/> `{ count, previous, next, {{ Post }, ... }` |


## Пост

| Конечная точка                                       | Доступные методы                             | Краткое описание                                        |
|------------------------------------------------------|----------------------------------------------|---------------------------------------------------------|
| [`/post/`](#Чтение-списка-постов-создание-постов)    | * GET,<br/>* POST                            | Чтение списка постов, создание поста                    |
| [`/post/my/`](#Мои-посты)                            | * GET                                        | Чтение списка постов, созданных автором                 |
| [`/post/<slug>/`](#Чтение-обновление-удаление-поста) | * GET,<br/>* PUT,<br/>* PATCH,<br/> * DELETE | Чтение поста, обновление поста, удаление поста          |
| [`/post/<slug>/publish/`](#Публикация-поста)         | * POST                                       | Публикация поста                                        |
| [`/post/<slug>/like/`](#Отметка-нравится)            | * POST,<br/> * DELETE                        | Добавление к посту, удаление у поста отметки "нравится" |
| [`/post/<slug>/comments/`](#Комментарии-поста)       | * GET                                        | Чтение списка комментариев поста                        |


### Чтение списка постов, создание постов
***

По данной конечной точке приложение отправляет список всех постов со всех блогов в порядке 
их новизны (начиная с поста, опубликованного недавно). Для списка сущностей постов 
реализованы [пагинация](#Пагинация), [сортировки](#Сортировка-поиск-фильтры-постов), 
[поиск](#Сортировка-поиск-фильтры-постов) и [фильтры](#Сортировка-поиск-фильтры-постов). 
Данные, полученные с этой конечной точки могут использоваться на странице `Главная`.

Также данная конечная точка используется для создания нового поста в блоге. 

> **Представления**: `PostViewSet`
> 
> **Сериализаторы**: `SlugSerializer`, `PostSerializer`, `CreatePostSerializer`

> **Права доступа** 
> 
> *Чтение* - доступно всем пользователям
> 
> *Запись* - доступно авторам блога и администратору

> [!NOTE]
> При создании поста, его слаг генерируется автоматически как: "`hex(Blog.pk)`"-"заголовок поста".
> Такой подход генерации слага делает запись поста уникальной в контексте одного блога и
> запрещает создавать несколько постов с одинаковым названием в одном блоге в целях экономии памяти.

| Метод |                Запрос                | Ответ                                                         |
|-------|:------------------------------------:|---------------------------------------------------------------|
| GET   |                  -                   | HTTP_200_OK <br/> `{ count, previous, next, {{ Post }, ... }` |
| POST  | `{blog_slug, title, body, tags: []}` | * HTTP_201_CREATED<br/>* HTTP_400_BAD_REQUEST                 |


### "Мои посты"
***

По данной конечной точке приложение отправляет список постов, созданных пользователем 
в порядке их новизны (начиная с поста, опубликованного недавно). Для списка сущностей постов 
реализованы [пагинация](#Пагинация), [сортировки](#Сортировка-поиск-фильтры-постов), 
[поиск](#Сортировка-поиск-фильтры-постов) и [фильтры](#Сортировка-поиск-фильтры-постов).

> **Представления**: `MyPostsListView`
> 
> **Сериализаторы**: `PostSerializer`

> **Права доступа** - доступно авторизованным пользователям

| Метод | Запрос | Ответ                                                         |
|-------|:------:|---------------------------------------------------------------|
| GET   |   -    | HTTP_200_OK <br/> `{ count, previous, next, {{ Post }, ... }` |


### Чтение, обновление, удаление поста
***

По данной конечной точке пользователь может извлечь определённую сущность поста, обновить 
или удалить её. При извлечении опубликованного поста, счётчик его просмотров увеличивается 
на 1.

> **Представления**: `PostViewSet`
> 
> **Сериализаторы**: `SlugSerializer`, `PostSerializer`, `UpdatePostSerializer`

> **Права доступа** 
> 
> *Чтение* - доступно авторизованным пользователям (Неопубликованный пост может получить
> только его автор или администратор)
> 
> *Обновление* - доступно только создателю поста или администратору
> 
> *Удаление* - доступно только создателю поста, владельцу блога или администратору

> [!WARNING]
> При удалении сущности поста, все комментарии под ним также удаляются.

| Метод  |                     Запрос                      | Ответ                                |
|--------|:-----------------------------------------------:|--------------------------------------|
| GET    |                        -                        | HTTP_200_OK <br/> `{{ Post }}`       |
| PUT    |            `{title, body, tags: []}`            | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| PATCH  | `{{title}}`<br/> `{{body}}`<br/> `{{tags: []}}` | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| DELETE |                        -                        | HTTP_204_NO_CONTENT                  |


### Публикация поста
***

По данной конечной точке создатель поста может опубликовать блог.

> **Представления**: `PostViewSet`
> 
> **Сериализаторы**: `PublishPostSerializer`

> **Права доступа** - доступно только создателю поста или администратору

> [!NOTE]
> Только после публикации поста, он будет виден всем пользователям, под ним 
> можно будет оставлять комментарии и ставить лайки.

| Метод | Запрос | Ответ               |
|-------|:------:|---------------------|
| POST  |   -    | HTTP_204_NO_CONTENT |


### Отметка "нравится"
***

По данной конечной точке пользователь может добавить посту отметку "нравится" 
или убрать её.

> **Представления**: `PostViewSet`
> 
> **Сериализаторы**: `LikeSerializer`

> **Права доступа** - доступно авторизованным пользователям

> [!NOTE]
> Так же как и у просмотров, при удалении пользователя, все его отметки "нравится" 
> сохраняются.

| Метод  | Запрос | Ответ               |
|--------|:------:|---------------------|
| POST   |   -    | HTTP_204_NO_CONTENT |
| DELETE |   -    | HTTP_204_NO_CONTENT |


### Комментарии поста
***

По данной конечной точке приложение отправляет список комментариев, находящихся 
под определённом постом. Для списка сущностей комментариев реализована [пагинация](#Пагинация).

> **Представления**: `PostCommentsListView`
> 
> **Сериализаторы**: `CommentSerializer`

> **Права доступа** - доступно всем пользователям

| Метод | Запрос | Ответ                                                            |
|-------|:------:|------------------------------------------------------------------|
| GET   |   -    | HTTP_200_OK <br/> `{ count, previous, next, {{ Comment }, ... }` |


## Комментарий

| Конечная точка                                              | Доступные методы                             | Краткое описание                                                 |
|-------------------------------------------------------------|----------------------------------------------|------------------------------------------------------------------|
| [`/comment/`](#Создание-комментария)                        | * POST                                       | Создание комментария                                             |
| [`/comment/<pk>/`](#Чтение-обновление-удаление-комментария) | * GET,<br/>* PUT,<br/>* PATCH,<br/> * DELETE | Чтение комментария, обновление комментария, удаление комментария |


### Создание комментария
***

Данная конечная точка используется для создания нового комментария под постом. 

> **Представления**: `CommentViewSet`
> 
> **Сериализаторы**: `CreateCommentSerializer`

> **Права доступа** - доступно авторизованным пользователям

| Метод | Запрос              | Ответ                                         |
|-------|---------------------|-----------------------------------------------|
| POST  | `{post_slug, body}` | * HTTP_201_CREATED<br/>* HTTP_400_BAD_REQUEST |


### Чтение, обновление, удаление комментария
***

По данной конечной точке пользователь может извлечь определённую сущность комментария, обновить 
или удалить её.

> **Представления**: `CommentViewSet`
> 
> **Сериализаторы**: `CommentSerializer`

> **Права доступа** 
> 
> *Чтение* - доступно авторизованным пользователям 
> 
> *Обновление, удаление* - доступно только создателю комментария или администратору

| Метод  |   Запрос   | Ответ                                |
|--------|:----------:|--------------------------------------|
| GET    |     -      | HTTP_200_OK <br/> `{{ Comment }}`    |
| PUT    |  `{body}`  | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| PATCH  | `{{body}}` | HTTP_200_OK<br/>HTTP_400_BAD_REQUEST |
| DELETE |     -      | HTTP_204_NO_CONTENT                  |


## Пользователь

В качестве представлений пользователя в приложении для обработки его действий была 
использована библиотечная REST-реализация [Djoser](https://djoser.readthedocs.io/en/latest/introduction.html).

С помощью данной библиотеки в приложении реализована аутентификация пользователей 
по токенам. В приложении пользователь может принимать две роли: `User` - обычный 
пользователь сервиса и `Admin` - администратор системы.

> [!IMPORTANT]
> По умолчанию после миграции если в приложении не существует ни одного пользователя 
> с ролью администратора - администратор создаётся автоматически с именем пользователя 
> `ADMIN` и паролем `admin`. Единственного администратора удалить из системы невозможно.


## Пагинация

Для реализации пагинации в приложении была использована стандартная технология `Django
REST Framework` - `PageNumberPagination`. Такой стиль разбивки на страницы принимает 
номер страницы в параметрах запроса: `GET https://api.example.org/accounts/?page=4`

По умолчанию на каждой странице отображается по 5 элементов объекта. Для изменения 
этого параметра необходимо отредактировать соответствующую строку в настройках 
проекта:

```yaml
'PAGE_SIZE': 5,
```

> Ссылка на официальную документацию по `PageNumberPagination` [тут](https://www.django-rest-framework.org/api-guide/pagination/#pagenumberpagination)


## Сортировка, Поиск, Фильтры

Возможность фильтрации в приложении реализована с помощью библиотеки `django-filter`. 
Она включает в себя `DjangoFilterBackend` класс, который поддерживает настраиваемую 
фильтрацию полей для `REST Framework`. Возможность поиска по полям набора объектов 
реализована через класс `SearchFilter`, а наборы и инструкции для фильтрации и сортировок 
прописаны в `FilterSet` классах для представления каждой модели.

> Полную документацию по библиотеке `django-filter` можно найти [тут](https://django-filter.readthedocs.io/en/stable/)


### Сортировка, поиск, фильтры блогов

Поиск блогов осуществляется по двум полям: *заголовок блога* и *имя владельца блога*

```python
search_fields = ['title', '=owner__username']
```

Знак `=` перед полем *имя владельца блога* означает поиск по точному совпадению. У поля 
*заголовок блога* поиск производится по правилу "наличие в". Для осуществления поиска 
в запросе прописывается параметр `.../?search=""`, в значении которого указывается информация 
для поиска.

За сортировку блогов отвечает класс `BlogRelevanceOrderingFilter`, который является наследником 
базового класса сортировки `OrderingFilter` и класса `NullLastOrderingFilter`. Последний отвечает 
за перемещение объектов со значением поля сортировки `Null` в конец. Класс сортировки блога 
поддерживает сортировку по таким полям, как: *заголовок блога*, *дата последней публикации* и 
*актуальность* в прямом и обратном порядке. Для осуществления сортировки в запросе 
прописывается параметр `.../?ordering=""`, в значении которого указывается поле, по которому 
проводится сортировка (для сортировки в обратом порядке перед значением поля указывается знак 
`-`, пример: `.../?ordering=-title`).

> [!NOTE]
> При сортировке блогов по актуальности, наиболее актуальными считаются недавно обновлённые блоги 
> с наибольшим кол-вом подписчиков.

Фильтрация блогов производится *по дате обновления от* и *по дате обновления до* (как вместе, так и 
раздельно). 

```python
from django_filters import DateFilter

date_from = DateFilter(field_name='updated_at', lookup_expr="gt")
date_to = DateFilter(field_name='updated_at', lookup_expr="lt")
```

Для осуществления фильтрации в запросе прописываются соответсвующее параметры: 
`.../?date_from=dd.mm.YYYY` и/или `../?date_to=dd.mm.YYYY`. Для использования 
параметров фильтрации вместе между ними прописывается знак `&`.


### Сортировка, поиск, фильтры постов

Поиск постов осуществляется по двум полям: *заголовок поста* и *имя автора*

```python
search_fields = ['title', '=author__username']
```

Знак `=` перед полем *имя автора* означает поиск по точному совпадению. У поля 
*заголовок поста* поиск производится по правилу "наличие в". Для осуществления поиска 
в запросе прописывается параметр `.../?search=""`, в значении которого указывается информация 
для поиска.

За сортировку постов отвечает класс `PostRelevanceOrderingFilter`, который является наследником 
базового класса сортировки `OrderingFilter` и класса `NullLastOrderingFilter`. Последний отвечает 
за перемещение объектов со значением поля сортировки `Null` в конец. Класс сортировки поста 
поддерживает сортировку по таким полям, как: *заголовок поста*, *дата публикации*, *отметки "нравится"* и 
*актуальность* в прямом и обратном порядке. Для осуществления сортировки в запросе 
прописывается параметр `.../?ordering=""`, в значении которого указывается поле, по которому 
проводится сортировка (для сортировки в обратом порядке перед значением поля указывается знак 
`-`, пример: `.../?ordering=-title`).

> [!NOTE]
> При сортировке постов по актуальности, наиболее актуальными считаются новые посты с наибольшим 
> кол-вом лайков и просмотров.

Фильтрация постов производится *по дате публикации от*, *по дате публикации до* и *тегам* (как вместе, так и 
раздельно). 

```python
from django_filters import DateFilter, ModelMultipleChoiceFilter
from taggit.models import Tag

date_from = DateFilter(field_name='created_at', lookup_expr="gt")
date_to = DateFilter(field_name='created_at', lookup_expr="lt")
tags = ModelMultipleChoiceFilter(field_name='tags__name', to_field_name='name', queryset=Tag.objects.all())
```

Для осуществления фильтрации в запросе прописываются соответсвующее параметры: 
`.../?date_from=dd.mm.YYYY` и/или `../?date_to=dd.mm.YYYY`. Для использования 
параметров фильтрации вместе между ними прописывается знак `&`. При фильтрации постов 
по тегам в параметре `.../?tags=""` указывается название тега. Для поиска по нескольким тегам 
параметр прописывается несколько раз через знак `&`. Пример: `.../?tags=tag1&tags=tag2`.


## Описание моделей

## Модель блога

Модель сущности блога `class Blog(models.Model)`, содержит такие поля, как:

* `slug` - слаг, уникальное поле (имя создателя-заголовок)
* `title` - заголовок блога
* `description` - описание блога
* `created_at` - время и дата создания блога
* `updated_at` - время и дата последнего обновления блога (по дате последней публикации)
* `authors` - авторы, добавляющие посты в блог
* `owner` - владелец блога

> :heavy_check_mark: Индексированные поля: `slug`, `updated_at`, `title`, `owner`.

Связана отношениями: один ко многим с сущностью пользователя через поле `owner`, 
многие ко многим с сущностями пользователей через поле `authors`, многие к одному с 
сущностями постов и многие ко многим с сущностями пользователей через модель `Subscription`.

Определяет метод получения общего кол-ва подписчиков:

```python
@property
def total_subscribers(self):
    return Subscription.objects.filter(blog=self).count()
```


## Модель поста

Модель сущности поста `class Post(models.Model):`, содержит такие поля, как:

* `slug` - слаг, уникальное поле (`hex(Blog.pk)`-заголовок)
* `title` - заголовок поста
* `body` - содержание поста
* `is_published` - флаг публикации поста
* `created_at` - время и дата публикации поста
* `views` - Счётчик просмотров поста
* `blog` - блог, в котором существует пост
* `author` - автор поста

> :heavy_check_mark: Индексированные поля: `slug`, `created_at`, `title`, `views`, `author`.

Связана отношениями: один ко многим с сущностью пользователя через поле `author`, 
один ко многим с сущностью блога через поле `blog`, многие к одному с 
сущностями комментариев и многие ко многим с сущностями пользователей через модель `Like`.

Определяет менеджер тегов `TaggableManager()` библиотеки `taggit`, который надстраивает 
модель сущности тегов и привязывает её связью многие ко многим к сущностям постов. 

> С документацией по `taggit` можно ознакомиться [тут](https://django-taggit.readthedocs.io/en/latest/)

Определяет метод получения общего кол-ва отметок "нравится":

```python
@property
def total_likes(self):
    return Like.objects.filter(post=self).count()
```


## Модель комментария

Модель сущности комментария `class Comment(models.Model)`, содержит такие поля, как:

* `body` - содержание комментария
* `created_at` - время и дата создания комментария
* `post` - пост, в котором существует комментарий
* `commented_by` - автор комментария

> :heavy_check_mark: Индексированные поля: `created_at`, `post`, `commented_by`.

Связана отношениями: один ко многим с сущностью пользователя через поле `commented_by` и  
один ко многим с сущностью поста через поле `post`.


## Модель отметки "нравится"

Модель связующей сущности отметки "нравится" `class Like(models.Model)`, содержит такие поля, как:

* `post` - понравившийся пост
* `created_at` - время и дата создания сущности
* `liked_by` - автор лайка

> Индексированные поля: `post`, `liked_by`.

Данная сущность выступает связующей в отношении многие ко многим между сущностями постов и пользователей, 
соответственно определяет отношения один ко многим с сущностью пользователя через поле `liked_by` и  
один ко многим с сущностью поста через поле `post`.

При удалении связанной сущности поста, данная сущность также удаляется, при удалении связанной сущности 
пользователя - сущность отметки "нравится" остаётся неизменной.


## Модель подписки

Модель связующей сущности подписки `class Subscription(models.Model)`, содержит такие поля, как:

* `blog` - блог для подписки
* `created_at` - время и дата создания сущности
* `user` - подписчик

> :heavy_check_mark: Индексированные поля: `blog`, `user`.

Данная сущность выступает связующей в отношении многие ко многим между сущностями блогов и пользователей, 
соответственно определяет отношения один ко многим с сущностью пользователя через поле `user` и  
один ко многим с сущностью блога через поле `blog`.

При удалении связанной сущности блога, как и сущности пользователя, сущность подписки также удаляется.


## Тестирование

В качестве тестов были реализованы UNIT-тест кейсы на всю бизнес-логику приложения и 
на тестирование прав доступа. Общее кол-во тестов - 35. Все тест кейсы прогоняются 
автоматически после развёртывания приложения.

Для запуска тестов вручную в корневой папке проекта необходимо выполнить следующую команду:

```bash
  pyton manage.py test content.tests
```


## Стек технологий

Приложение написано на `Django` версии 5.0.2 с использованием `DRF` версии 3.14. 
Для запуска приложение использует `python` версии 3.10. 

С полным списком используемых библиотек можно ознакомиться в файле [requirements.txt](/socialnet/requirements.txt)

В качестве СУБД используется `PostgreSQL` версии 12.

Разработка приложения полностью велась в интегрированной среде разработки `PyCharm CE`.


## Используемые источники

- Официальная документация [Django](https://docs.djangoproject.com/en/5.0/)
- Официальная документация [Django REST Framework](https://www.django-rest-framework.org/)
- Официальная документация [Djoser](https://djoser.readthedocs.io/en/latest/index.html)
- Официальная документация [Taggit](https://django-taggit.readthedocs.io/en/latest/)
- Официальная документация [Django Filter](https://django-filter.readthedocs.io/en/stable/)
